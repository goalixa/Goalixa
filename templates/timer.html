{% extends "layout.html" %}
{% set title = "Timer" %}
{% set active_page = "timer" %}

{% block head_extra %}
  <link rel="stylesheet" href="{{ url_for('static', filename='vendor/litepicker/litepicker.css') }}" />
{% endblock %}

{% block content %}
  <div class="timer-page">
    <header class="timer-hero">
        <div class="timer-controls">
          <div class="timer-select">
            <label class="timer-input-label" for="task-picker">Current task</label>
            <div class="timer-input-group">
              <input
                id="task-picker"
                type="text"
                placeholder="What are you working on?"
                autocomplete="off"
                aria-expanded="false"
                aria-controls="task-dropdown"
              />
              <button class="timer-clear" id="task-clear" type="button" aria-label="Clear selected task" disabled>
                <i class="bi bi-x"></i>
              </button>
            </div>
            <div class="timer-dropdown" id="task-dropdown">
              <div class="timer-bulk-controls">
                <span class="timer-bulk-count" id="timer-bulk-count">0 selected</span>
                <button class="btn btn-outline-secondary btn-xs" id="timer-bulk-clear" type="button" disabled>
                  Clear
                </button>
                <button class="btn btn-outline-primary btn-xs" id="timer-bulk-apply" type="button" disabled>
                  Apply
                </button>
              </div>
              <div class="timer-list" id="timer-search-list">
                <div class="timer-empty-state">Loading tasks...</div>
              </div>
            </div>
          </div>
          <div class="daily-target-inline">
            <label class="timer-input-label" for="focus-compact-time">Today's Target</label>
            <div class="focus-compact">
              <div class="focus-time" id="focus-compact-time">
                <span class="focus-segment is-active" data-segment="hours">00</span>
                <span class="focus-separator">:</span>
                <span class="focus-segment" data-segment="minutes">00</span>
              </div>
              <div class="focus-compact-actions">
                <button class="btn btn-outline-secondary btn-xs" type="button" id="focus-compact-minus" aria-label="Decrease target">-</button>
                <button class="btn btn-outline-secondary btn-xs" type="button" id="focus-compact-plus" aria-label="Increase target">+</button>
                <button class="btn btn-outline-primary btn-sm" type="button" id="daily-target-set" aria-label="Save target">
                  <i class="bi bi-check2"></i>
                </button>
              </div>
            </div>
          </div>
        </div>
      </header>
    <section class="timer-range-section">
      <div class="timer-range-card">
        <div class="timer-range-left">
          <div class="calendar-row">
            <input class="calendar-input" id="timer-range" type="text" readonly />
          </div>
        </div>
        <div class="timer-range-summary">
          <div class="timer-summary-item">
            <span class="timer-summary-label">TODAY</span>
            <span class="timer-summary-value">{{ today_total_seconds | format_seconds }}</span>
          </div>
          <div class="timer-summary-item">
            <span class="timer-summary-label">WEEK TOTAL</span>
            <span class="timer-summary-value">{{ week_total_seconds | format_seconds }}</span>
          </div>
        </div>
        <div class="timer-range-right">
          <div class="timer-view-toggle" role="tablist" aria-label="View options">
            <button class="timer-view-tab" data-view-button="calendar" role="tab" aria-selected="false" title="Calendar view">
              <i class="bi bi-calendar-week"></i>
              <span class="view-label">Calendar</span>
            </button>
            <button class="timer-view-tab" data-view-button="list" role="tab" aria-selected="false" title="List view">
              <i class="bi bi-list-task"></i>
              <span class="view-label">List</span>
            </button>
            <button class="timer-view-tab is-active" data-view-button="timesheet" role="tab" aria-selected="true" title="Timesheet view">
              <i class="bi bi-clock-history"></i>
              <span class="view-label">Timesheet</span>
            </button>
          </div>
        </div>
      </div>
    </section>
    <section class="timer-range-section">
      <div class="card pomodoro-card" data-tour-id="pomodoro">
        {% set progress = today_target_seconds and (today_total_seconds / today_target_seconds * 100) | round(1) or 0 %}
        <div class="focus-progress" aria-live="polite">
          <div class="focus-progress-bar" aria-label="Daily focus progress">
            <div class="focus-progress-fill" style="width: {{ [progress,100]|min }}%"></div>
          </div>
        </div>
        <div class="pomodoro-header">
          <div class="pomodoro-copy">
            <p class="pomodoro-label">Pomodoro</p>
            <h2 class="pomodoro-mode" id="pomodoro-mode">Focus</h2>
            <div class="pomodoro-status">
              <p class="pomodoro-task" id="pomodoro-task">No task selected</p>
              <p class="pomodoro-meta" id="pomodoro-meta" aria-live="polite">Session 1 of 4</p>
            </div>
            <div class="pomodoro-dots" aria-hidden="true">
              <span data-session-dot="1"></span>
              <span data-session-dot="2"></span>
              <span data-session-dot="3"></span>
              <span data-session-dot="4"></span>
            </div>
          </div>
          <div class="pomodoro-clock">
            <div class="pomodoro-ring">
              <div class="pomodoro-dial" id="pomodoro-display" role="timer" aria-live="polite">25:00</div>
              <span class="pomodoro-caption">Remaining</span>
            </div>
          </div>
        </div>
        <div class="pomodoro-controls">
          <button class="btn btn-primary btn-sm" type="button" id="pomodoro-toggle">
            <i class="bi bi-play-fill" id="pomodoro-toggle-icon"></i>
            <span id="pomodoro-toggle-text">Start</span>
          </button>
          <button class="btn btn-outline-secondary btn-sm" type="button" id="pomodoro-reset">
            <i class="bi bi-arrow-counterclockwise"></i>
            <span class="btn-text">Reset</span>
          </button>
          <button class="btn btn-outline-secondary btn-sm" type="button" id="pomodoro-skip">
            <i class="bi bi-skip-forward-fill"></i>
            <span class="btn-text">Skip</span>
          </button>
          <button class="btn btn-outline-success btn-sm" type="button" id="pomodoro-done">
            <i class="bi bi-check2-circle"></i>
            <span class="btn-text">Done today</span>
          </button>
        </div>
        <div class="pomodoro-presets">
          <button class="btn btn-light btn-sm" type="button" data-pomodoro-mode="work">Focus 25</button>
          <button class="btn btn-light btn-sm" type="button" data-pomodoro-mode="short">Break 5</button>
          <button class="btn btn-light btn-sm" type="button" data-pomodoro-mode="long">Break 15</button>
        </div>
      </div>
    </section>
    <section class="timer-range-section timer-task-create-section">
      <div class="card timer-task-create-card">
        <div class="timer-task-create-header">
          <div>
            <p class="timer-input-label">Quick add</p>
            <h3 class="timer-task-create-title">Add task</h3>
          </div>
        </div>
        <form
          class="task-form timer-quick-task-form"
          id="timer-quick-task-form"
          method="post"
          action="{{ url_for('create_task') }}"
        >
          <input
            id="timer-quick-task-name"
            type="text"
            name="name"
            placeholder="Task name"
            required
          />
          <select id="timer-quick-task-project" name="project_id">
            <option value="" selected>No project</option>
            {% for project in projects %}
              <option value="{{ project['id'] }}">{{ project['name'] }}</option>
            {% endfor %}
          </select>
          <select id="timer-quick-task-priority" name="priority">
            <option value="low">Low priority</option>
            <option value="medium" selected>Medium priority</option>
            <option value="high">High priority</option>
          </select>
          <select id="timer-quick-task-label" name="label_ids">
            <option value="" selected>Label (optional)</option>
            {% for label in labels %}
              <option value="{{ label['id'] }}">{{ label['name'] }}</option>
            {% endfor %}
          </select>
          <button class="btn btn-primary btn-sm" type="submit">
            <i class="bi bi-plus-lg"></i>
            Add task
          </button>
        </form>
        <p
          class="timer-quick-task-feedback"
          id="timer-quick-task-feedback"
          role="status"
          aria-live="polite"
          hidden
        ></p>
      </div>
    </section>
    <section class="timer-calendar-section timer-view-panel" data-view-panel="calendar">
      <div class="card timer-calendar-card">
        <div class="calendar-week-board">
          <div class="calendar-week-grid calendar-week-header-row">
            <div class="calendar-weekday calendar-task-header">Tasks</div>
            {% for day in week_days %}
              <div class="calendar-weekday{% if day.is_today %} is-today{% endif %}">
                <span class="calendar-weekday-name">{{ day.day }}</span>
                <span class="calendar-weekday-date">{{ day.date }}</span>
              </div>
            {% endfor %}
          </div>
          {% if task_rows %}
            <div class="calendar-week-body">
              {% for task in task_rows %}
                <div class="calendar-week-grid calendar-week-row">
                  <div class="calendar-task-cell">
                    <span class="calendar-task-name">{{ task["name"] }}</span>
                    <span class="calendar-task-meta">
                      {% if task["project_name"] %}{{ task["project_name"] }}{% else %}No project{% endif %}
                    </span>
                  </div>
                  {% for day in week_days %}
                    {% set checked = task.week_checks[loop.index0] %}
                    <div class="calendar-day-cell{% if day.is_today %} is-today{% endif %}">
                      <span
                        class="calendar-check{% if checked %} is-checked{% elif day.is_future %}{% else %} is-missed{% endif %}"
                        title="{{ day.full }}"
                      ></span>
                    </div>
                  {% endfor %}
                </div>
              {% endfor %}
            </div>
          {% else %}
            <p class="empty">No tasks yet.</p>
          {% endif %}
        </div>
      </div>
    </section>
    <section class="timer-calendar-section timer-view-panel" data-view-panel="list">
      <div class="card timer-list-card">
        {% if timer_list_groups %}
          {% for group in timer_list_groups | reverse %}
            <div class="timer-list-group">
              <div class="timer-list-header">
                <span class="timer-list-day">{{ group["label"] }}</span>
                <span class="timer-list-total">{{ group["total_seconds"] | format_seconds }}</span>
              </div>
              {% for task in group["tasks"] %}
                <div class="timer-list-item timer-task-item" data-task-id="{{ task['task_id'] }}">
                  <div class="timer-list-row timer-task-toggle" role="button" tabindex="0" aria-expanded="false" data-task-toggle>
                    <div class="timer-list-left">
                      {% if task["labels"] %}
                        <span class="timer-list-label">{{ task["labels"] | join(", ") }}</span>
                      {% endif %}
                    </div>
                    <div class="timer-list-center">
                      <span class="timer-list-title">{{ task["task_name"] }}</span>
                      <span class="timer-list-project">{{ task["project_name"] }}</span>
                    </div>
                    <div class="timer-list-right">
                      <span class="timer-list-duration">{{ task["total_seconds"] | format_seconds }}</span>
                      <span class="timer-list-time">{{ task["entries"] | length }} sessions</span>
                      <div class="timer-list-actions">
                        {% if task["is_running"] %}
                          <form method="post" action="{{ url_for('stop_task', task_id=task['task_id']) }}" data-action="stop" data-task-id="{{ task['task_id'] }}" data-task-name="{{ task['task_name'] }}">
                            <button class="btn btn-outline-warning btn-sm timer-list-action pause" type="submit" aria-label="Pause task timer">
                              <i class="bi bi-pause-fill"></i>
                            </button>
                          </form>
                        {% else %}
                          <form method="post" action="{{ url_for('start_task', task_id=task['task_id']) }}" data-action="start" data-task-id="{{ task['task_id'] }}" data-task-name="{{ task['task_name'] }}">
                            <button class="btn btn-outline-primary btn-sm timer-list-action resume" type="submit" aria-label="Start task timer">
                              <i class="bi bi-play-fill"></i>
                            </button>
                          </form>
                        {% endif %}
                      </div>
                    </div>
                  </div>
                  <div class="timer-task-details">
                    {% for entry in task["entries"] %}
                      <div class="timer-task-entry">
                        <span class="timer-task-entry-time">{{ entry["start_time"] }} - {{ entry["end_time"] }}</span>
                        <span class="timer-task-entry-duration">{{ entry["duration_seconds"] | format_seconds }}</span>
                      </div>
                    {% endfor %}
                  </div>
                </div>
              {% endfor %}
            </div>
          {% endfor %}
        {% else %}
          <div class="timer-empty-state">No entries yet.</div>
        {% endif %}
      </div>
    </section>
    <section class="timer-calendar-section timer-view-panel is-active" data-view-panel="timesheet">
      <div class="card timer-timesheet-card">
        {% if timer_list_groups %}
          <div class="timesheet-header">
            <div>
              <h3 class="timesheet-title">Timesheet</h3>
              <p class="timesheet-subtitle">Grouped by day for the selected range.</p>
              {% if today_target_seconds %}
                {% set target_reached = today_total_seconds >= today_target_seconds %}
                <div class="timesheet-target-banner {% if target_reached %}is-success{% endif %}">
                  <span class="timesheet-target-label">
                    <i class="bi {% if target_reached %}bi-emoji-smile{% else %}bi-flag{% endif %}"></i>
                    Today's target: {{ today_target_seconds | format_seconds }}
                  </span>
                  <span class="timesheet-target-progress">
                    {{ today_total_seconds | format_seconds }} / {{ today_target_seconds | format_seconds }}
                  </span>
                  {% if target_reached %}
                    <span class="timesheet-target-congrats">Great job! You hit today's focus goal.</span>
                  {% endif %}
                </div>
              {% endif %}
            </div>
          </div>
          <div class="timesheet-table">
            {% for group in timer_list_groups | reverse %}
              <div class="timesheet-row">
                <div class="timesheet-day">
                  <div class="timesheet-day-label">{{ group["label"] }}</div>
                  <div class="timesheet-day-total">{{ group["total_seconds"] | format_seconds }}</div>
                </div>
                <div class="timesheet-entries">
                  {% if group["tasks"] %}
                    {% for task in group["tasks"] %}
                      <div class="timesheet-task" data-task-id="{{ task['task_id'] }}">
                        <div class="timesheet-task-summary" role="button" tabindex="0" aria-expanded="false" data-task-toggle>
                          <div>
                            <div class="timesheet-task-title">{{ task["task_name"] }}</div>
                            <div class="timesheet-task-meta">{{ task["project_name"] }}</div>
                          </div>
                          <div class="timesheet-task-duration">{{ task["total_seconds"] | format_seconds }}</div>
                        </div>
                        <div class="timesheet-task-details">
                          {% for entry in task["entries"] %}
                            <div class="timer-task-entry">
                              <span class="timer-task-entry-time">{{ entry["start_time"] }} - {{ entry["end_time"] }}</span>
                              <span class="timer-task-entry-duration">{{ entry["duration_seconds"] | format_seconds }}</span>
                            </div>
                          {% endfor %}
                        </div>
                      </div>
                    {% endfor %}
                  {% else %}
                    <div class="timer-empty-state">No entries for this day.</div>
                  {% endif %}
                </div>
              </div>
            {% endfor %}
          </div>
        {% else %}
          <div class="timer-empty-state">No timesheet data yet.</div>
        {% endif %}
      </div>
    </section>
  </div>
{% endblock %}

{% block scripts %}
  <script src="{{ url_for('static', filename='vendor/litepicker/litepicker.js') }}"></script>
  <script>
    window.todayTotalSeconds = {{ today_total_seconds | int }};
    window.todayTargetSeconds = {{ today_target_seconds | int }};
    window.todayDate = "{{ today_date }}";
    let targetSeconds = Math.max(0, Number(window.todayTargetSeconds || 2 * 3600));

    const formatSeconds = (seconds) => {
      const safe = Math.max(0, Math.floor(seconds || 0));
      const h = Math.floor(safe / 3600);
      const m = Math.floor((safe % 3600) / 60);
      const s = safe % 60;
      return `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
    };

    const formatHM = (seconds) => {
      const safe = Math.max(0, Math.floor(seconds || 0));
      const h = Math.floor(safe / 3600);
      const m = Math.floor((safe % 3600) / 60);
      return `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}`;
    };

    const setProgressFill = () => {
      const fill = document.querySelector(".focus-progress-fill");
      if (!fill) return;
      const target = Math.max(0, Number(targetSeconds || 0));
      if (!target) {
        fill.style.width = "0%";
        return;
      }
      const current = Number(window.todayTotalSeconds || 0);
      const percent = Math.min(100, (current / target) * 100);
      fill.style.width = `${percent}%`;
    };

    document.addEventListener("DOMContentLoaded", () => {
      const rangeInput = document.getElementById("timer-range");
      if (rangeInput && typeof Litepicker !== "undefined") {
        const today = new Date();
        const startValue = "{{ timer_range_start or '' }}";
        const endValue = "{{ timer_range_end or '' }}";
        const start = startValue ? new Date(`${startValue}T00:00:00`) : new Date(today);
        const end = endValue ? new Date(`${endValue}T00:00:00`) : new Date(today);
        if (!startValue) {
          start.setDate(today.getDate() - 6);
        }
        const picker = new Litepicker({
          element: rangeInput,
          singleMode: false,
          startDate: start,
          endDate: end,
          showTooltip: false,
          numberOfMonths: 1,
          numberOfColumns: 1,
          format: "YYYY-MM-DD",
        });
        rangeInput.value = `${picker.getStartDate().format("YYYY-MM-DD")} → ${picker
          .getEndDate()
          .format("YYYY-MM-DD")}`;
        picker.on("selected", (date1, date2) => {
          if (!date1 || !date2) {
            return;
          }
          const nextStart = date1.format("YYYY-MM-DD");
          const nextEnd = date2.format("YYYY-MM-DD");
          window.location.search = `?start=${nextStart}&end=${nextEnd}`;
        });
      }

      const panels = document.querySelectorAll("[data-view-panel]");
      const viewTabs = document.querySelectorAll(".timer-view-tab");
      const taskPicker = document.getElementById("task-picker");
      const taskDropdown = document.querySelector(".timer-dropdown");
      const taskList = document.getElementById("timer-search-list");
      const timerBulkCount = document.getElementById("timer-bulk-count");
      const timerBulkClear = document.getElementById("timer-bulk-clear");
      const timerBulkApply = document.getElementById("timer-bulk-apply");
      const timerQuickTaskForm = document.getElementById("timer-quick-task-form");
      const timerQuickTaskName = document.getElementById("timer-quick-task-name");
      const timerQuickTaskProject = document.getElementById("timer-quick-task-project");
      const timerQuickTaskPriority = document.getElementById("timer-quick-task-priority");
      const timerQuickTaskLabel = document.getElementById("timer-quick-task-label");
      const timerQuickTaskFeedback = document.getElementById("timer-quick-task-feedback");
      let cachedTasks = [];
      let selectedTaskIds = new Set();

      const setQuickTaskFeedback = (message, state = "") => {
        if (!timerQuickTaskFeedback) {
          return;
        }
        timerQuickTaskFeedback.textContent = message || "";
        timerQuickTaskFeedback.hidden = !message;
        timerQuickTaskFeedback.classList.toggle("is-success", state === "success");
        timerQuickTaskFeedback.classList.toggle("is-error", state === "error");
      };

      const setTimeDisplay = () => {
        const timeLabel = document.getElementById("focus-compact-time");
        const sec = Math.max(0, Number(targetSeconds || 0));
        const h = Math.floor(sec / 3600);
        const m = Math.floor((sec % 3600) / 60);
        if (timeLabel) {
          const [hoursEl, minutesEl] = timeLabel.querySelectorAll(".focus-segment");
          if (hoursEl) hoursEl.textContent = String(h).padStart(2, "0");
          if (minutesEl) minutesEl.textContent = String(m).padStart(2, "0");
        }
      };

      const submitDailyTarget = () => {
        const seconds = Math.max(0, targetSeconds);
        if (!seconds) return;
        fetch("/api/daily-target", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ target_seconds: seconds }),
        })
          .then((res) => (res.ok ? res.json() : null))
          .then((payload) => {
            if (!payload) return;
            window.todayTargetSeconds = Number(payload.today_target_seconds || 0);
            targetSeconds = window.todayTargetSeconds;
            document.getElementById("focus-progress-total").textContent = formatHM(
              window.todayTargetSeconds,
            );
            const pct = (
              (Number(window.todayTotalSeconds || 0) / (window.todayTargetSeconds || 1)) *
              100
            ).toFixed(1);
            document.getElementById("focus-progress-percent").textContent = pct;
            setTimeDisplay();
            setProgressFill();
          })
          .catch(() => {});
      };

      viewTabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          const targetView = tab.dataset.viewButton;
          viewTabs.forEach((t) => {
            t.classList.toggle("is-active", t === tab);
            t.setAttribute("aria-selected", t === tab ? "true" : "false");
          });
          panels.forEach((panel) =>
            panel.classList.toggle("is-active", panel.dataset.viewPanel === targetView),
          );
        });
      });

      const toggleTaskDetails = (toggle) => {
        const item = toggle.closest(".timer-task-item, .timesheet-task");
        if (!item) {
          return;
        }
        const isOpen = item.classList.toggle("is-open");
        toggle.setAttribute("aria-expanded", isOpen ? "true" : "false");
      };

      document.addEventListener("click", (event) => {
        const toggle = event.target.closest("[data-task-toggle]");
        if (!toggle) {
          return;
        }
        if (event.target.closest(".timer-list-actions")) {
          return;
        }
        toggleTaskDetails(toggle);
      });

      document.addEventListener("keydown", (event) => {
        if (event.key !== "Enter" && event.key !== " ") {
          return;
        }
        const toggle = event.target.closest("[data-task-toggle]");
        if (!toggle) {
          return;
        }
        event.preventDefault();
        toggleTaskDetails(toggle);
      });

      const dailyTargetSet = document.getElementById("daily-target-set");
      setTimeDisplay();

      if (dailyTargetSet) {
        dailyTargetSet.addEventListener("click", submitDailyTarget);
      }
      // Fill daily target progress bar
      setProgressFill();
      const focusTimeLabel = document.getElementById("focus-compact-time");

      const updateRangeUI = () => {
        setTimeDisplay();
        const totalText = document.getElementById("focus-progress-total");
        if (totalText) {
          totalText.textContent = formatHM(targetSeconds);
        }
        const pct = (
          (Number(window.todayTotalSeconds || 0) / (targetSeconds || 1)) *
          100
        ).toFixed(1);
        const pctEl = document.getElementById("focus-progress-percent");
        if (pctEl) {
          pctEl.textContent = pct;
        }
        setProgressFill();
      };

      let activeSegment = "hours";
      const hoursEl = document.querySelector('.focus-segment[data-segment="hours"]');
      const minutesEl = document.querySelector('.focus-segment[data-segment="minutes"]');

      const setActive = (segment) => {
        activeSegment = segment;
        if (hoursEl) hoursEl.classList.toggle("is-active", segment === "hours");
        if (minutesEl) minutesEl.classList.toggle("is-active", segment === "minutes");
      };

      const adjustTarget = (delta) => {
        const step = activeSegment === "hours" ? 3600 : 60;
        targetSeconds = Math.max(0, targetSeconds + delta * step);
        updateRangeUI();
      };

      if (hoursEl) hoursEl.addEventListener("click", () => setActive("hours"));
      if (minutesEl) minutesEl.addEventListener("click", () => setActive("minutes"));

      const minusBtn = document.getElementById("focus-compact-minus");
      const plusBtn = document.getElementById("focus-compact-plus");
      if (minusBtn) minusBtn.addEventListener("click", () => adjustTarget(-1));
      if (plusBtn) plusBtn.addEventListener("click", () => adjustTarget(1));
      updateRangeUI();

      const pomodoroDisplay = document.getElementById("pomodoro-display");
      const pomodoroMode = document.getElementById("pomodoro-mode");
      const pomodoroTask = document.getElementById("pomodoro-task");
      const pomodoroMeta = document.getElementById("pomodoro-meta");
      const pomodoroRing = document.querySelector(".pomodoro-ring");
      const pomodoroDots = document.querySelectorAll("[data-session-dot]");
      const taskClear = document.getElementById("task-clear");
      const toggleButton = document.getElementById("pomodoro-toggle");
      const toggleIcon = document.getElementById("pomodoro-toggle-icon");
      const toggleText = document.getElementById("pomodoro-toggle-text");
      const resetButton = document.getElementById("pomodoro-reset");
      const skipButton = document.getElementById("pomodoro-skip");
      const doneButton = document.getElementById("pomodoro-done");
      const presetButtons = document.querySelectorAll("[data-pomodoro-mode]");
      const baseTitle = document.title;

      const presets = {
        work: 25 * 60,
        short: 5 * 60,
        long: 15 * 60,
      };

      const storageKey = "pomodoroState";
      let intervalId = null;
      let audioContext = null;

      const defaultState = {
        mode: "work",
        remaining: presets.work,
        isRunning: false,
        completedWork: 0,
        lastTick: null,
        taskId: null,
        taskIds: [],
        taskNames: [],
        taskRunning: false,
      };

      const loadState = () => {
        try {
          const raw = localStorage.getItem(storageKey);
          if (!raw) {
            return { ...defaultState };
          }
          const parsed = JSON.parse(raw);
          return {
            ...defaultState,
            ...parsed,
          };
        } catch (error) {
          return { ...defaultState };
        }
      };

      const saveState = (state) => {
        localStorage.setItem(storageKey, JSON.stringify(state));
      };

      const normalizeStateTaskIds = (state) => {
        const ids = Array.isArray(state.taskIds)
          ? state.taskIds
          : state.taskId
            ? [state.taskId]
            : [];
        const unique = [];
        const seen = new Set();
        ids.forEach((value) => {
          const parsed = Number.parseInt(String(value), 10);
          if (!Number.isFinite(parsed) || parsed <= 0 || seen.has(parsed)) {
            return;
          }
          seen.add(parsed);
          unique.push(parsed);
        });
        state.taskIds = unique;
        state.taskId = unique.length ? unique[0] : null;
        if (!Array.isArray(state.taskNames)) {
          state.taskNames = [];
        }
      };

      const setStateTasks = (state, tasks) => {
        const cleaned = (tasks || []).filter((task) => task && task.id);
        state.taskIds = cleaned.map((task) => Number(task.id));
        state.taskNames = cleaned.map((task) => task.name || `Task #${task.id}`);
        state.taskId = state.taskIds.length ? state.taskIds[0] : null;
        state.taskName = state.taskNames.length ? state.taskNames[0] : null;
      };

      const formatClock = (seconds) => {
        const safe = Math.max(0, Math.floor(seconds || 0));
        const minutes = Math.floor(safe / 60);
        const remaining = safe % 60;
        return `${String(minutes).padStart(2, "0")}:${String(remaining).padStart(2, "0")}`;
      };

      const modeLabel = (mode) => {
        if (mode === "short") {
          return "Short Break";
        }
        if (mode === "long") {
          return "Long Break";
        }
        return "Focus";
      };

      const updatePageTitle = (state) => {
        if (!state.isRunning) {
          document.title = baseTitle;
          return;
        }
        normalizeStateTaskIds(state);
        const time = formatClock(state.remaining);
        const mode = modeLabel(state.mode);
        const taskLabel =
          state.taskIds.length > 1
            ? ` - ${state.taskIds.length} tasks`
            : state.taskName
              ? ` - ${state.taskName}`
              : "";
        document.title = `${time} · ${mode}${taskLabel}`;
      };

      const updatePomodoroUI = (state) => {
        if (!pomodoroDisplay || !pomodoroMode || !pomodoroMeta) {
          return;
        }
        normalizeStateTaskIds(state);
        pomodoroDisplay.textContent = formatClock(state.remaining);
        pomodoroMode.textContent = modeLabel(state.mode);
        const nextSession = (state.completedWork % 4) + 1;
        pomodoroMeta.textContent = `Session ${nextSession} of 4`;
        if (pomodoroTask) {
          if (!state.taskIds.length) {
            pomodoroTask.textContent = "No task selected";
          } else if (state.taskIds.length === 1) {
            pomodoroTask.textContent = state.taskName
              ? `Task: ${state.taskName}`
              : "Task selected";
          } else {
            const preview = (state.taskNames || []).slice(0, 2).join(", ");
            const extra = state.taskNames.length > 2
              ? ` +${state.taskNames.length - 2}`
              : "";
            pomodoroTask.textContent = preview
              ? `Working simultaneously: ${preview}${extra}`
              : `Working simultaneously on ${state.taskIds.length} tasks`;
          }
        }
        if (pomodoroDots.length) {
          const completed = state.completedWork % 4;
          pomodoroDots.forEach((dot, index) => {
            dot.classList.toggle("is-active", index < completed);
            dot.classList.toggle("is-current", index === completed);
          });
        }
        if (pomodoroRing) {
          const total = presets[state.mode] || 0;
          const progress =
            total > 0 ? Math.min(1, Math.max(0, state.remaining / total)) : 0;
          pomodoroRing.style.setProperty("--pomodoro-progress", `${progress * 360}deg`);
        }
        const requiresTask = state.mode === "work" && !state.taskIds.length;
        if (toggleButton) {
          toggleButton.disabled = requiresTask;
          if (state.isRunning) {
            toggleIcon.className = "bi bi-pause-fill";
            toggleText.textContent = "Pause";
            toggleButton.classList.remove("btn-primary");
            toggleButton.classList.add("btn-warning");
          } else {
            toggleIcon.className = "bi bi-play-fill";
            toggleText.textContent = requiresTask ? "Select task" : "Start";
            toggleButton.classList.remove("btn-warning");
            toggleButton.classList.add("btn-primary");
          }
        }
        if (doneButton) {
          doneButton.disabled = !state.taskIds.length;
        }
          if (taskClear) {
            taskClear.disabled = !state.taskIds.length;
          }
          updatePageTitle(state);
        };

      const getNextMode = (state) => {
        if (state.mode === "work") {
          const nextWork = state.completedWork + 1;
          return nextWork % 4 === 0 ? "long" : "short";
        }
        return "work";
      };

      const applyMode = (state, mode) => {
        const duration = presets[mode];
        return {
          ...state,
          mode,
          remaining: duration,
          isRunning: false,
          lastTick: null,
          taskRunning: false,
        };
      };

      const ensureAudioContext = () => {
        if (!audioContext) {
          const AudioCtx = window.AudioContext || window.webkitAudioContext;
          if (AudioCtx) {
            audioContext = new AudioCtx();
          }
        }
        return audioContext;
      };

      const playChime = () => {
        const ctx = ensureAudioContext();
        if (!ctx) {
          return;
        }
        const now = ctx.currentTime;
        const tones = [523.25, 659.25, 783.99];
        tones.forEach((freq, index) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = "sine";
          osc.frequency.value = freq;
          gain.gain.setValueAtTime(0, now + index * 0.18);
          gain.gain.linearRampToValueAtTime(0.2, now + index * 0.18 + 0.02);
          gain.gain.exponentialRampToValueAtTime(0.001, now + index * 0.18 + 0.16);
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.start(now + index * 0.18);
          osc.stop(now + index * 0.18 + 0.2);
        });
      };

      const requestNotifications = () => {
        if (!("Notification" in window)) {
          return;
        }
        if (Notification.permission === "default") {
          Notification.requestPermission().catch(() => {});
        }
      };

      const sendNotification = (title, body) => {
        if (!("Notification" in window)) {
          return;
        }
        if (Notification.permission === "granted") {
          new Notification(title, { body });
        }
      };

      const notifyPomodoro = (completedMode, nextMode) => {
        const toastTitle = completedMode === "work" ? "Focus complete" : "Break complete";
        const toastBody =
          completedMode === "work" ? "Time for a break." : "Time to focus.";
        if (typeof window.showPomodoroToast === "function") {
          window.showPomodoroToast(toastTitle, toastBody);
        }
        if (completedMode === "work") {
          sendNotification("Focus complete", "Time for a break.");
        } else {
          sendNotification("Break complete", "Time to focus.");
        }
        playChime();
      };

      const applyElapsed = (state, elapsedSeconds) => {
        const startingRemaining = state.remaining;
        let remaining = state.remaining;
        let mode = state.mode;
        let completedWork = state.completedWork;
        let secondsLeft = elapsedSeconds;
        let completedAny = false;

        while (secondsLeft > 0) {
          if (remaining > secondsLeft) {
            remaining -= secondsLeft;
            secondsLeft = 0;
          } else {
            secondsLeft -= remaining;
            notifyPomodoro(mode, mode === "work" ? "break" : "work");
            if (mode === "work") {
              completedWork += 1;
            }
            mode = mode === "work" ? (completedWork % 4 === 0 ? "long" : "short") : "work";
            remaining = presets[mode];
            completedAny = true;
          }
        }

        state.remaining = remaining;
        state.mode = mode;
        state.completedWork = completedWork;
        if (elapsedSeconds >= startingRemaining) {
          state.isRunning = false;
          state.lastTick = null;
          state.taskRunning = false;
        }
        if (completedAny && state.mode !== "work") {
          state.isRunning = true;
          state.lastTick = Date.now();
        }
      };

      const stopInterval = () => {
        if (intervalId) {
          clearInterval(intervalId);
          intervalId = null;
        }
      };

      const startTaskTimer = async (state) => {
        normalizeStateTaskIds(state);
        if (!state.taskIds.length || state.taskRunning) {
          return;
        }
        state.taskRunning = true;
        saveState(state);
        try {
          const response = await fetch("/api/tasks/bulk", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              task_ids: state.taskIds,
              action: "start",
            }),
          });
          if (!response.ok) {
            throw new Error("Failed to start selected tasks");
          }
        } catch (error) {
          state.taskRunning = false;
          saveState(state);
          console.error(error);
        }
      };

      const stopTaskTimer = async (state) => {
        normalizeStateTaskIds(state);
        if (!state.taskIds.length || !state.taskRunning) {
          return;
        }
        state.taskRunning = false;
        saveState(state);
        try {
          const response = await fetch("/api/tasks/bulk", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              task_ids: state.taskIds,
              action: "stop",
            }),
          });
          if (!response.ok) {
            throw new Error("Failed to stop selected tasks");
          }
        } catch (error) {
          console.error(error);
        }
      };

      const startInterval = (state) => {
        stopInterval();
        state.lastTick = Date.now();
        intervalId = setInterval(() => {
          const now = Date.now();
          const elapsed = Math.max(1, Math.floor((now - (state.lastTick || now)) / 1000));
          state.lastTick = now;
          state.remaining -= elapsed;
          if (state.remaining <= 0) {
            if (state.mode === "work") {
              stopTaskTimer(state);
            }
            notifyPomodoro(state.mode, getNextMode(state));
            state.remaining = 0;
            state.isRunning = false;
            if (state.mode === "work") {
              state.completedWork += 1;
            }
            const nextMode = getNextMode(state);
            const nextState = applyMode(state, nextMode);
            state.mode = nextState.mode;
            state.remaining = nextState.remaining;
            state.lastTick = null;
            stopInterval();
            if (nextMode !== "work") {
              state.isRunning = true;
              state.lastTick = Date.now();
              startInterval(state);
            }
          }
          saveState(state);
          updatePomodoroUI(state);
        }, 1000);
      };

      if (pomodoroDisplay) {
        const state = loadState();
        normalizeStateTaskIds(state);
        if (!state.taskNames.length && state.taskName) {
          state.taskNames = [state.taskName];
        }
        state.taskName = state.taskName || null;
        if (state.isRunning && state.lastTick) {
          const elapsed = Math.floor((Date.now() - state.lastTick) / 1000);
          if (elapsed > 0) {
            applyElapsed(state, elapsed);
          }
        }
        updatePomodoroUI(state);
        if (state.isRunning) {
          startInterval(state);
        }

        const startPomodoro = () => {
          normalizeStateTaskIds(state);
          if (state.mode === "work" && !state.taskIds.length) {
            alert("Select a task for this Pomodoro.");
            return;
          }
          requestNotifications();
          state.isRunning = true;
          state.lastTick = Date.now();
          if (state.mode === "work") {
            startTaskTimer(state);
          }
          saveState(state);
          updatePomodoroUI(state);
          startInterval(state);
        };

        const pausePomodoro = () => {
          state.isRunning = false;
          state.lastTick = null;
          stopTaskTimer(state);
          saveState(state);
          updatePomodoroUI(state);
          stopInterval();
        };

        const togglePomodoro = () => {
          if (state.isRunning) {
            pausePomodoro();
          } else {
            startPomodoro();
          }
        };

        toggleButton?.addEventListener("click", togglePomodoro);

        resetButton?.addEventListener("click", () => {
          state.mode = "work";
          state.remaining = presets.work;
          state.isRunning = false;
          state.completedWork = 0;
          state.lastTick = null;
          stopTaskTimer(state);
          saveState(state);
          updatePomodoroUI(state);
          stopInterval();
        });

        skipButton?.addEventListener("click", () => {
          if (state.mode === "work") {
            state.completedWork += 1;
          }
          stopTaskTimer(state);
          const nextMode = getNextMode(state);
          const nextState = applyMode(state, nextMode);
          state.mode = nextState.mode;
          state.remaining = nextState.remaining;
          state.isRunning = false;
          state.lastTick = null;
          saveState(state);
          updatePomodoroUI(state);
          stopInterval();
        });

        doneButton?.addEventListener("click", async () => {
          normalizeStateTaskIds(state);
          if (!state.taskIds.length) {
            alert("Select a task to mark it done today.");
            return;
          }
          try {
            if (state.taskIds.length === 1) {
              await fetch(`/api/tasks/${state.taskIds[0]}/daily-check`, { method: "POST" });
            } else {
              await fetch("/api/tasks/bulk", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  task_ids: state.taskIds,
                  action: "daily-check",
                }),
              });
            }
            if (typeof window.showPomodoroToast === "function") {
              window.showPomodoroToast(
                "Marked done",
                `${state.taskIds.length} task(s) checked off for today.`,
              );
            }
          } catch (error) {
            console.error(error);
          }
        });

        presetButtons.forEach((button) => {
          button.addEventListener("click", () => {
            const mode = button.dataset.pomodoroMode;
            if (!mode || !presets[mode]) {
              return;
            }
            stopTaskTimer(state);
            state.mode = mode;
            state.remaining = presets[mode];
            state.isRunning = false;
            state.lastTick = null;
            saveState(state);
            updatePomodoroUI(state);
            stopInterval();
          });
        });

        taskClear?.addEventListener("click", () => {
          if (state.isRunning && state.mode === "work") {
            pausePomodoro();
          }
          state.taskId = null;
          state.taskName = null;
          state.taskIds = [];
          state.taskNames = [];
          if (taskPicker) {
            taskPicker.value = "";
          }
          if (cachedTasks.length) {
            renderTasks(cachedTasks, "");
          }
          saveState(state);
          updatePomodoroUI(state);
        });

        const formatSeconds = (totalSeconds) => {
          const safe = Math.max(0, Math.floor(totalSeconds || 0));
          const hours = Math.floor(safe / 3600);
          const minutes = Math.floor((safe % 3600) / 60);
          const seconds = safe % 60;
          return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
        };

        const escapeHtml = (value) => {
          const div = document.createElement("div");
          div.textContent = value;
          return div.innerHTML;
        };

        const normalizeTaskId = (value) => {
          const parsed = Number.parseInt(String(value), 10);
          if (!Number.isFinite(parsed) || parsed <= 0) {
            return "";
          }
          return String(parsed);
        };

        const mergeTaskPayload = (payload) => {
          const merged = [
            ...(payload.tasks || []),
            ...(payload.done_today_tasks || []),
            ...(payload.completed_tasks || []),
          ];
          const byId = new Map();
          merged.forEach((task) => {
            const taskId = normalizeTaskId(task.id);
            if (taskId) {
              byId.set(taskId, task);
            }
          });
          return Array.from(byId.values()).sort(
            (a, b) => (b.total_seconds || 0) - (a.total_seconds || 0),
          );
        };

        const filterTasks = (tasks, query) => {
          const term = (query || "").toLowerCase().trim();
          return tasks.filter((task) => {
            const name = (task.name || "").toLowerCase();
            const project = (task.project_name || "").toLowerCase();
            return !term || name.includes(term) || project.includes(term);
          });
        };

        const getFilteredTasks = () =>
          filterTasks(cachedTasks, taskPicker ? taskPicker.value : "");

        const syncSelectedTaskIds = (tasks) => {
          const availableIds = new Set(
            (tasks || [])
              .filter((task) => (task.status || "active") !== "completed")
              .map((task) => normalizeTaskId(task.id))
              .filter(Boolean),
          );
          selectedTaskIds = new Set(
            Array.from(selectedTaskIds).filter((taskId) => availableIds.has(taskId)),
          );
        };

        const updateBulkControls = (visibleTasks = []) => {
          if (timerBulkCount) {
            timerBulkCount.textContent = `${selectedTaskIds.size} selected`;
          }
          if (timerBulkApply) {
            timerBulkApply.disabled = selectedTaskIds.size === 0;
          }
          if (timerBulkClear) {
            timerBulkClear.disabled = selectedTaskIds.size === 0;
          }
        };

        const renderTasks = (tasks, query) => {
          if (!taskList) {
            return;
          }
          syncSelectedTaskIds(tasks);
          const filtered = filterTasks(tasks, query);
          if (!filtered.length) {
            taskList.innerHTML = "<div class=\"timer-empty-state\">No tasks found.</div>";
            updateBulkControls(filtered);
            return;
          }
          taskList.innerHTML = filtered
            .map((task) => {
              const taskId = normalizeTaskId(task.id);
              const isSelected = selectedTaskIds.has(taskId);
              const isCompleted = (task.status || "active") === "completed";
              const name = escapeHtml(task.name || "");
              const projectName = task.project_name ? escapeHtml(task.project_name) : "";
              const project = projectName ? ` • ${projectName}` : "";
              const total = formatSeconds(task.total_seconds || 0);
              const statusLabel = isCompleted ? "Completed" : "Active";
              return `<div class="timer-task-option${isSelected ? " is-selected" : ""}">
                        <label class="timer-task-check-wrap" aria-label="Select ${name}">
                          <input class="timer-task-check" type="checkbox" data-task-check-id="${taskId}" ${isSelected ? "checked" : ""} ${isCompleted ? "disabled" : ""} />
                        </label>
                        <button
                          type="button"
                          class="timer-task-pick${isCompleted ? " is-completed" : ""}"
                          data-task-id="${taskId}"
                          ${isCompleted ? "disabled" : ""}
                        >
                          <span>${name}${project}</span>
                          <span class="timer-task-meta">${statusLabel} · ${total}</span>
                        </button>
                      </div>`;
            })
            .join("");
          updateBulkControls(filtered);
        };

        if (timerQuickTaskForm && timerQuickTaskName) {
          timerQuickTaskForm.addEventListener("submit", async (event) => {
            event.preventDefault();

            const name = timerQuickTaskName.value.trim();
            if (!name) {
              return;
            }

            const submitButton = timerQuickTaskForm.querySelector('button[type="submit"]');
            if (submitButton) {
              submitButton.disabled = true;
            }
            setQuickTaskFeedback("");

            try {
              const selectedLabelId =
                timerQuickTaskLabel && timerQuickTaskLabel.value
                  ? timerQuickTaskLabel.value
                  : "";
              const response = await fetch("/api/tasks", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  name,
                  project_id:
                    timerQuickTaskProject && timerQuickTaskProject.value
                      ? timerQuickTaskProject.value
                      : null,
                  priority:
                    timerQuickTaskPriority && timerQuickTaskPriority.value
                      ? timerQuickTaskPriority.value
                      : "medium",
                  label_ids: selectedLabelId ? [selectedLabelId] : [],
                }),
              });
              if (!response.ok) {
                throw new Error("Failed to add task");
              }
              const payload = await response.json();
              cachedTasks = mergeTaskPayload(payload);
              selectedTaskIds.clear();
              renderTasks(cachedTasks, taskPicker ? taskPicker.value : "");
              timerQuickTaskName.value = "";
              timerQuickTaskName.focus();
              if (timerQuickTaskPriority) {
                timerQuickTaskPriority.value = "medium";
              }
              if (timerQuickTaskLabel) {
                timerQuickTaskLabel.value = "";
              }
              setQuickTaskFeedback("Task added.", "success");
            } catch (error) {
              console.error(error);
              setQuickTaskFeedback("Saving failed. Falling back to full submit.", "error");
              HTMLFormElement.prototype.submit.call(timerQuickTaskForm);
            } finally {
              if (submitButton) {
                submitButton.disabled = false;
              }
            }
          });
        }

        const selectTask = (selected) => {
          if (!selected) {
            return;
          }
          normalizeStateTaskIds(state);
          const previousTaskIds = [...state.taskIds];
          if (state.isRunning) {
            pausePomodoro();
          }
          const newTaskIds = [Number(selected.id)];
          const sameSelection =
            previousTaskIds.length === newTaskIds.length &&
            previousTaskIds.every((taskId, index) => Number(taskId) === newTaskIds[index]);
          if (!state.isRunning && state.taskRunning && previousTaskIds.length && !sameSelection) {
            fetch("/api/tasks/bulk", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                task_ids: previousTaskIds,
                action: "stop",
              }),
            }).catch(() => {});
          }
          setStateTasks(state, [selected]);
          state.taskRunning = Boolean(selected.is_running);
          if (taskPicker) {
            taskPicker.value = selected.name;
          }
          if (state.mode !== "work" || state.remaining !== presets.work) {
            state.mode = "work";
            state.remaining = presets.work;
            state.isRunning = false;
            state.lastTick = null;
          }
          renderTasks(cachedTasks, "");
          closeDropdown();
          saveState(state);
          updatePomodoroUI(state);
          if (!state.isRunning) {
            startPomodoro();
          }
        };

        const applyBulkAction = async () => {
          const taskIds = Array.from(selectedTaskIds);
          if (!taskIds.length) {
            return;
          }
          normalizeStateTaskIds(state);
          const previousTaskIds = [...state.taskIds];
          const sameSelection =
            previousTaskIds.length === taskIds.length &&
            previousTaskIds.every((taskId) =>
              taskIds.includes(normalizeTaskId(taskId)),
            );

          if (timerBulkApply) {
            timerBulkApply.disabled = true;
          }

          try {
            if (state.taskRunning && previousTaskIds.length && !sameSelection) {
              const stopResponse = await fetch("/api/tasks/bulk", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  task_ids: previousTaskIds,
                  action: "stop",
                }),
              });
              if (!stopResponse.ok) {
                throw new Error("Failed to switch running tasks");
              }
            }
            const response = await fetch("/api/tasks/bulk", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                task_ids: taskIds,
                action: "start",
              }),
            });
            if (!response.ok) {
              throw new Error("Failed to apply bulk action");
            }
            const payload = await response.json();
            cachedTasks = mergeTaskPayload(payload);
            selectedTaskIds.clear();
            const selectedTasks = taskIds
              .map((taskId) =>
                cachedTasks.find((task) => String(task.id) === String(taskId)),
              )
              .filter(Boolean);
            if (selectedTasks.length) {
              setStateTasks(state, selectedTasks);
              state.taskRunning = true;
              if (taskPicker) {
                taskPicker.value =
                  selectedTasks.length === 1
                    ? selectedTasks[0].name || ""
                    : "";
              }
            }

            saveState(state);
            updatePomodoroUI(state);
            renderTasks(cachedTasks, taskPicker ? taskPicker.value : "");

            if (typeof window.showPomodoroToast === "function") {
              window.showPomodoroToast(
                "Timers started",
                `${taskIds.length} task timer(s) started simultaneously.`,
              );
            }
          } catch (error) {
            console.error(error);
          } finally {
            updateBulkControls(getFilteredTasks());
          }
        };

        const openDropdown = () => {
          taskDropdown?.classList.add("is-open");
          taskPicker?.setAttribute("aria-expanded", "true");
        };

        const closeDropdown = () => {
          taskDropdown?.classList.remove("is-open");
          taskPicker?.setAttribute("aria-expanded", "false");
        };

        if (taskPicker && taskDropdown && taskList) {
          fetch("/api/tasks")
            .then((response) => response.json())
            .then((payload) => {
              cachedTasks = mergeTaskPayload(payload);
              const runningTask = cachedTasks.find(
                (task) => task.is_running && (task.status || "active") !== "completed",
              );
              if (runningTask && !state.taskIds.length && !state.taskId) {
                setStateTasks(state, [runningTask]);
                state.mode = "work";
                state.isRunning = true;
                state.lastTick = Date.now();
                state.taskRunning = true;
                updatePomodoroUI(state);
                startInterval(state);
              }
              if (state.taskIds.length || state.taskId) {
                const preferredIds = state.taskIds.length
                  ? state.taskIds
                  : [state.taskId];
                const selectedTasks = preferredIds
                  .map((taskId) =>
                    cachedTasks.find((task) => String(task.id) === String(taskId)),
                  )
                  .filter(Boolean);
                if (selectedTasks.length) {
                  setStateTasks(state, selectedTasks);
                  state.taskRunning = selectedTasks.some((task) => task.is_running);
                  taskPicker.value =
                    selectedTasks.length === 1
                      ? selectedTasks[0].name || ""
                      : "";
                  updatePomodoroUI(state);
                } else {
                  state.isRunning = false;
                  state.lastTick = null;
                  state.taskId = null;
                  state.taskName = null;
                  state.taskIds = [];
                  state.taskNames = [];
                  state.taskRunning = false;
                  stopInterval();
                  taskPicker.value = "";
                  saveState(state);
                  updatePomodoroUI(state);
                }
              }
              renderTasks(cachedTasks, taskPicker.value);

              taskPicker.addEventListener("focus", () => {
                openDropdown();
              });

              taskPicker.addEventListener("click", () => {
                openDropdown();
              });

              taskPicker.addEventListener("input", () => {
                openDropdown();
                renderTasks(cachedTasks, taskPicker.value);
              });

              taskPicker.addEventListener("keydown", (event) => {
                if (event.key === "ArrowDown") {
                  event.preventDefault();
                  openDropdown();
                  const firstButton = taskList?.querySelector(".timer-task-pick:not([disabled])");
                  if (firstButton) {
                    firstButton.focus();
                  }
                }
                if (event.key === "Enter") {
                  const candidates = filterTasks(cachedTasks, taskPicker.value).filter(
                    (task) => (task.status || "active") !== "completed",
                  );
                  if (candidates.length) {
                    event.preventDefault();
                    selectTask(candidates[0]);
                  }
                }
                if (event.key === "Escape") {
                  closeDropdown();
                }
              });

              taskList.addEventListener("click", (event) => {
                const target = event.target;
                if (!(target instanceof HTMLElement)) {
                  return;
                }
                const button = target.closest("button.timer-task-pick[data-task-id]");
                if (!button || button.disabled) {
                  return;
                }
                const taskId = button.dataset.taskId;
                const selected = cachedTasks.find(
                  (task) => String(task.id) === String(taskId),
                );
                selectTask(selected);
              });

              taskList.addEventListener("change", (event) => {
                const target = event.target;
                if (!(target instanceof HTMLInputElement)) {
                  return;
                }
                if (!target.classList.contains("timer-task-check")) {
                  return;
                }
                const taskId = normalizeTaskId(target.dataset.taskCheckId || target.value);
                if (!taskId) {
                  return;
                }
                if (target.checked) {
                  selectedTaskIds.add(taskId);
                } else {
                  selectedTaskIds.delete(taskId);
                }
                renderTasks(cachedTasks, taskPicker.value);
              });

              timerBulkClear?.addEventListener("click", () => {
                selectedTaskIds.clear();
                renderTasks(cachedTasks, taskPicker.value);
              });

              timerBulkApply?.addEventListener("click", () => {
                applyBulkAction();
              });

              document.addEventListener("click", (event) => {
                if (!(event.target instanceof HTMLElement)) {
                  return;
                }
                if (
                  !event.target.closest(".timer-select") &&
                  !event.target.closest(".timer-dropdown")
                ) {
                  closeDropdown();
                }
              });
            })
            .catch((error) => {
              console.error(error);
            });
        }
      }
    });
  </script>
{% endblock %}
